// src/app/auth/login.tsx
'use client'
import React from 'react'
import AuthLayout from '@layouts/AuthLayout'
import LoginForm from '@components/auth/LoginForm'

export default function LoginPage() {
  return (
    <AuthLayout>
      <div className="max-w-md mx-auto">
        <LoginForm />
      </div>
    </AuthLayout>
  )
}

// src/app/auth/register.tsx
'use client'
import React from 'react'
import AuthLayout from '@layouts/AuthLayout'
import RegisterForm from '@components/auth/RegisterForm'

export default function RegisterPage() {
  return (
    <AuthLayout>
      <div className="max-w-md mx-auto">
        <RegisterForm />
      </div>
    </AuthLayout>
  )
}

// src/app/dashboard/page.tsx
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import VideoCard from '@components/dashboard/VideoCard'
import StatsChart from '@components/dashboard/StatsChart'

export default function DashboardPage() {
  // Placeholder data
  const videos = [
    { thumbnail: '/images/video1.jpg', title: 'Video 1', status: 'Published' },
    { thumbnail: '/images/video2.jpg', title: 'Video 2', status: 'Processing' },
  ]
  const chartLabels = ['Jan', 'Feb', 'Mar', 'Apr']
  const chartData = [100, 150, 200, 250]

  return (
    <DashboardLayout>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {videos.map((video, idx) => (
          <VideoCard
            key={idx}
            thumbnail={video.thumbnail}
            title={video.title}
            status={video.status}
          />
        ))}
      </div>
      <div className="mt-8">
        <StatsChart labels={chartLabels} data={chartData} />
      </div>
    </DashboardLayout>
  )
}
// src/app/publishing/page.tsx
'use client'
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'

export default function PublishingPage() {
  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">
          Publishing & Content Management
        </h2>
        {/* <TODO>: Add components to manage publishing status, metadata, etc. */}
        <p>Publishing management interface goes here.</p>
      </div>
    </DashboardLayout>
  )
}
// src/app/settings/page.tsx
'use client'
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'

export default function SettingsPage() {
  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">Settings</h2>
        {/* <TODO>: TTS Configuration and user preferences form */}
        <p>Settings interface goes here.</p>
      </div>
    </DashboardLayout>
  )
}
// src/app/video-editor/page.tsx
'use client'
import React, { useState } from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import VideoPreview from '@components/video/VideoPreview'
import VideoEditor from '@components/video/VideoEditor'
import Timeline from '@components/video/Timeline'

export default function VideoEditorPage() {
  const [videoUrl] = useState('<TODO: Video URL>')

  return (
    <DashboardLayout>
      <h2 className="text-2xl font-bold mb-4">Video Editor</h2>
      <div className="mb-4">
        <VideoPreview videoUrl={videoUrl} />
      </div>
      <VideoEditor />
      <div className="mt-8">
        <Timeline />
      </div>
    </DashboardLayout>
  )
}
// src/app/layout.tsx
import type { Metadata } from 'next'
import { Geist, Geist_Mono } from 'next/font/google'
import '@styles/globals.css'
import React from 'react'
import Providers from '@components/providers/Providers' // âœ… Import Client Component

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
})

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
})

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
// src/app/page.tsx
'use client'
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'

export default function HomePage() {
  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h1 className="text-3xl font-bold">Welcome to Vision Forge Project</h1>
        <p className="mt-2">
          This is the landing page. <strong>Explore features...</strong>
        </p>
      </div>
    </DashboardLayout>
  )
}
// src/config/env.ts
const env = {
  API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api',
  JWT_SECRET: process.env.JWT_SECRET || 'your_jwt_secret_here',
}
// Add another environment variable
export default env

// src/hooks/useAuth.ts
import { useSelector } from 'react-redux'
import type { RootState } from '@store/store'
import { useCallback } from 'react'
import { useAppDispatch } from '@store/store'
import { setCredentials, logout } from '@store/authSlice'
// Import authService for API calls
import { loginAPI } from '@modules/auth/authAPI'

const useAuth = () => {
  const dispatch = useAppDispatch()
  const auth = useSelector((state: RootState) => state.auth)

  const login = useCallback(
    async (credentials: { email: string; password: string }) => {
      // Call API (placeholder)
      const data = await loginAPI(credentials) // <TODO: Implement actual API call
      dispatch(setCredentials({ user: data.user, token: data.token }))
    },
    [dispatch]
  )

  const signOut = useCallback(() => {
    // Clear token and user info
    dispatch(logout())
    // Additional cleanup if needed
  }, [dispatch])

  return { auth, login, signOut }
}

export default useAuth


// src/hooks/useFetch.ts
import { useQuery } from '@tanstack/react-query'
import axios from 'axios'

// Generic hook for fetching data
const useFetch = <T>(key: string, url: string) => {
  return useQuery<T>({
    queryKey: [key],
    queryFn: async () => {
      const response = await axios.get(url)
      return response.data
    },
  })
}

export default useFetch

// src/hooks/useModal.ts
import { useState, useCallback } from 'react'

const useModal = () => {
  const [isOpen, setIsOpen] = useState(false)

  const openModal = useCallback(() => setIsOpen(true), [])
  const closeModal = useCallback(() => setIsOpen(false), [])

  return { isOpen, openModal, closeModal }
}

export default useModal

// src/hooks/useTheme.ts
import { useSelector, useDispatch } from 'react-redux'
import type { RootState } from '../store/store'
import { setTheme } from '../store/settingsSlice'
import { useCallback } from 'react'

const useTheme = () => {
  const dispatch = useDispatch()
  const theme = useSelector((state: RootState) => state.settings.theme)

  const toggleTheme = useCallback(() => {
    dispatch(setTheme(theme === 'light' ? 'dark' : 'light'))
  }, [dispatch, theme])

  return { theme, toggleTheme }
}

export default useTheme

// src/layouts/AuthLayout.tsx
import React from 'react'

const AuthLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      {children}
    </div>
  )
}

export default AuthLayout


// src/layouts/DashboardLayout.tsx
'use client'
import React from 'react'
import Header from '@components/layout/Header'
import Sidebar from '@components/layout/Sidebar'
import Footer from '@components/layout/Footer'

const DashboardLayout: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="flex flex-1">
        <Sidebar />
        <main className="flex-1 p-4">{children}</main>
      </div>
      <Footer />
    </div>
  )
}

export default DashboardLayout

// src/middleware/authMiddleware.ts
import { NextApiRequest, NextApiResponse, NextApiHandler } from 'next'
import jwt from 'jsonwebtoken'

export function authMiddleware(handler: NextApiHandler) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    const authHeader = req.headers.authorization
    if (!authHeader) {
      res.status(401).json({ error: 'Authorization header missing' })
      return
    }
    const token = authHeader.split(' ')[1]
    try {
      // <TODO>: Replace with your actual secret or public key
      jwt.verify(token, process.env.JWT_SECRET as string)
      return handler(req, res)
    } catch {
      res.status(401).json({ error: 'Invalid or expired token' })
    }
  }
}

// src/middleware/errorHandler.ts
import { NextApiRequest, NextApiResponse } from 'next'

interface Error {
  statusCode?: number
  message?: string
}

export default function errorHandler(
  err: Error,
  req: NextApiRequest,
  res: NextApiResponse
) {
  console.error('Error:', err)
  res
    .status(err.statusCode || 500)
    .json({ error: err.message || 'Internal Server Error' })
}

// src/modules/analytics/analyticsAPI.ts
import api from '@services/api'

export const fetchAnalyticsData = async () => {
  const response = await api.get('/analytics') // <TODO>: Adjust endpoint
  return response.data
}
// src/modules/analytics/AnalyticsPage.tsx
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import StatsChart from '@components/dashboard/StatsChart'
import { useQuery } from '@tanstack/react-query'
import { fetchAnalyticsData } from './analyticsAPI'

export default function AnalyticsPage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['analyticsData'],
    queryFn: fetchAnalyticsData,
  })

  if (isLoading) return <div>Loading analytics...</div>
  if (error) return <div>Error loading analytics.</div>

  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">Analytics Dashboard</h2>
        <StatsChart labels={data.labels} data={data.values} />
      </div>
    </DashboardLayout>
  )
}
// src/modules/analytics/analyticsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface AnalyticsState {
  data: unknown
}

const initialState: AnalyticsState = {
  data: {},
}

const analyticsSlice = createSlice({
  name: 'analytics',
  initialState,
  reducers: {
    setAnalyticsData(state, action: PayloadAction<unknown>) {
      state.data = action.payload
    },
  },
})

export const { setAnalyticsData } = analyticsSlice.actions
export default analyticsSlice.reducer
// src/modules/auth/authAPI.ts
import api from '@services/api'

export const loginAPI = async (credentials: {
  email: string
  password: string
}) => {
  const response = await api.post('/auth/login', credentials) // <TODO>: Adjust endpoint
  return response.data
}

export interface RegisterCredentials {
  email: string
  password: string
  name?: string
  // Add other fields your registration requires
}

export const registerAPI = async (data: RegisterCredentials) => {
  const response = await api.post('/auth/register', data) // <TODO>: Adjust endpoint
  return response.data
}
// src/modules/auth/AuthPage.tsx
import React from 'react'
import AuthLayout from '@layouts/AuthLayout'
import LoginForm from '@components/auth/LoginForm'

export default function AuthPage() {
  // <TODO>: Toggle between LoginForm and RegisterForm based on user action
  return (
    <AuthLayout>
      <div className="max-w-md mx-auto">
        <LoginForm />
        {/* <RegisterForm /> */}
      </div>
    </AuthLayout>
  )
}
// src/modules/auth/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

export interface User {
  id: string
  name: string
  email: string
}

interface AuthState {
  user: User | null
  token: string | null
}

const initialState: AuthState = {
  user: null,
  token: null,
}

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setCredentials(
      state,
      action: PayloadAction<{ user: User; token: string }>
    ) {
      state.user = action.payload.user
      state.token = action.payload.token
    },
    logout(state) {
      state.user = null
      state.token = null
    },
  },
})

export const { setCredentials, logout } = authSlice.actions
export default authSlice.reducer
// src/modules/dashboard/dashboardAPI.ts
import api from '@services/api'

export const fetchDashboardData = async () => {
  const response = await api.get('/dashboard') // <TODO>: Adjust endpoint if needed
  return response.data
}
// src/modules/dashboard/DashboardPage.tsx
import React from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import { useQuery } from '@tanstack/react-query'
import { fetchDashboardData } from './dashboardAPI'
import VideoCard from '@components/dashboard/VideoCard'
import StatsChart from '@components/dashboard/StatsChart'
import { Video } from './dashboardSlice'

export default function DashboardModulePage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['dashboardData'],
    queryFn: fetchDashboardData,
  })

  if (isLoading) return <div>Loading dashboard...</div>
  if (error) return <div>Error loading dashboard.</div>

  return (
    <DashboardLayout>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {data.videos.map((video: Video, idx: number) => (
          <VideoCard
            key={idx}
            thumbnail={video.thumbnail}
            title={video.title}
            status={video.status}
          />
        ))}
      </div>
      <div className="mt-8">
        <StatsChart labels={data.chartLabels} data={data.chartData} />
      </div>
    </DashboardLayout>
  )
}
// src/modules/dashboard/dashboardSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

export interface Video {
  id: string
  thumbnail: string
  title: string
  status: string
}

interface Stats {
  [key: string]: number
}

interface DashboardState {
  videos: Video[]
  stats: Stats
}

const initialState: DashboardState = {
  videos: [],
  stats: {},
}

const dashboardSlice = createSlice({
  name: 'dashboard',
  initialState,
  reducers: {
    setDashboardData(state, action: PayloadAction<DashboardState>) {
      state.videos = action.payload.videos
      state.stats = action.payload.stats
    },
  },
})

export const { setDashboardData } = dashboardSlice.actions
export default dashboardSlice.reducer
// src/modules/publishing/publishingAPI.ts
import api from '../../services/api'

export const fetchPublishingData = async () => {
  const response = await api.get('/publishing') // <TODO>: Adjust endpoint
  return response.data
}

export const publishVideo = async (videoId: string, data: unknown) => {
  const response = await api.post(`/publishing/${videoId}`, data) // <TODO>: Adjust endpoint
  return response.data
}
// src/modules/publishing/PublishingPage.tsx
import React from 'react'
import DashboardLayout from '../../layouts/DashboardLayout'
import Button from '../../components/common/Button'

export default function PublishingPage() {
  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">
          Publishing & Content Management
        </h2>
        {/* <TODO>: Add list of videos with status and management options */}
        <p>Publishing management interface placeholder.</p>
        <Button
          className="mt-4"
          onClick={() => {
            /* <TODO>: Trigger publish action */
          }}
        >
          Publish New Video
        </Button>
      </div>
    </DashboardLayout>
  )
}
// src/modules/publishing/publishingSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { Video } from '../dashboard/dashboardSlice'

interface PublishingState {
  videos: Video[]
}

const initialState: PublishingState = {
  videos: [],
}

const publishingSlice = createSlice({
  name: 'publishing',
  initialState,
  reducers: {
    setPublishingVideos(state, action: PayloadAction<Video[]>) {
      state.videos = action.payload
    },
  },
})

export const { setPublishingVideos } = publishingSlice.actions
export default publishingSlice.reducer
// src/modules/tts/ttsAPI.ts
import api from '@services/api'

interface TTSConfig {
  voice: string
  speed: number
  tone: number
  volume: number
}

export const fetchTTSConfig = async () => {
  const response = await api.get('/tts/config') // <TODO>: Adjust endpoint
  return response.data
}

export const updateTTSConfig = async (config: TTSConfig) => {
  const response = await api.put('/tts/config', config) // <TODO>: Adjust endpoint
  return response.data
}
// src/modules/tts/TTSConfigurator.tsx
import React, { useState } from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import SelectInput from '@components/forms/SelectedInput'
import Input from '@components/common/Input'
import Button from '@components/common/Button'

const voiceOptions = [
  { value: 'default', label: 'Default Voice' },
  { value: 'voice1', label: 'Voice 1' },
  { value: 'voice2', label: 'Voice 2' },
]

export default function TTSConfigurator() {
  const [voice, setVoice] = useState('default')
  const [speed, setSpeed] = useState(1)
  const [tone, setTone] = useState(1)
  const [volume, setVolume] = useState(1)

  const handleSave = async () => {
    // <TODO>: Call API to update TTS configuration
    console.log({ voice, speed, tone, volume })
  }

  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">TTS Configuration</h2>
        <SelectInput
          label="Voice"
          value={voice}
          onChange={(e) => setVoice(e.target.value as string)}
          options={voiceOptions}
        />
        <Input
          type="number"
          value={speed}
          onChange={(e) => setSpeed(Number(e.target.value))}
          placeholder="Speed"
          fullWidth
          className="mt-4"
        />
        <Input
          type="number"
          value={tone}
          onChange={(e) => setTone(Number(e.target.value))}
          placeholder="Tone"
          fullWidth
          className="mt-4"
        />
        <Input
          type="number"
          value={volume}
          onChange={(e) => setVolume(Number(e.target.value))}
          placeholder="Volume"
          fullWidth
          className="mt-4"
        />
        <Button onClick={handleSave} className="mt-4">
          Save Configuration
        </Button>
      </div>
    </DashboardLayout>
  )
}
// src/modules/tts/ttsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface TTSState {
  config: {
    voice: string
    speed: number
    tone: number
    volume: number
  }
}

const initialState: TTSState = {
  config: {
    voice: 'default',
    speed: 1,
    tone: 1,
    volume: 1,
  },
}

const ttsSlice = createSlice({
  name: 'tts',
  initialState,
  reducers: {
    setTTSConfig(state, action: PayloadAction<TTSState['config']>) {
      state.config = action.payload
    },
  },
})

export const { setTTSConfig } = ttsSlice.actions
export default ttsSlice.reducer
// src/modules/video/videoAPI.ts
import api from '@services/api'
import { Video } from '../dashboard/dashboardSlice'

export const fetchVideos = async () => {
  const response = await api.get('/videos') // <TODO>: Adjust endpoint
  return response.data
}

export const createVideo = async (data: Video) => {
  const response = await api.post('/videos', data) // <TODO>: Adjust endpoint
  return response.data
}

export const updateVideo = async (id: string, data: Video) => {
  const response = await api.put(`/videos/${id}`, data) // <TODO>: Adjust endpoint
  return response.data
}
// src/modules/video/VideoCreator.tsx
import React, { useState } from 'react'
import DashboardLayout from '@layouts/DashboardLayout'
import TextEditor from '@components/forms/TextEditor'
import Button from '@components/common/Button'
import VideoPreview from '@components/video/VideoPreview'

export default function VideoCreator() {
  const [script, setScript] = useState('')
  const [videoUrl] = useState('<TODO: Video URL>')

  const handleGenerateVideo = async () => {
    // <TODO>: Call API to generate video from script
    console.log('Generating video for script:', script)
  }

  return (
    <DashboardLayout>
      <div className="container mx-auto p-4">
        <h2 className="text-2xl font-bold mb-4">Scientific Video Creator</h2>
        <TextEditor value={script} onChange={setScript} />
        <Button onClick={handleGenerateVideo} className="mt-4">
          Generate Video
        </Button>
        <div className="mt-8">
          <VideoPreview videoUrl={videoUrl} />
        </div>
      </div>
    </DashboardLayout>
  )
}
// src/modules/video/videoSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { Video } from '../dashboard/dashboardSlice'

interface VideoState {
  list: Video[]
  id: number
}

const initialState: VideoState = {
  list: [],
  id: 0,
}

const videoSlice = createSlice({
  name: 'video',
  initialState,
  reducers: {
    setVideos(state, action: PayloadAction<Video[]>) {
      state.list = action.payload
    },
    addVideo(state, action: PayloadAction<Video>) {
      state.list.push(action.payload)
    },
    updateVideoInList(state, action: PayloadAction<Video>) {
      const index = state.list.findIndex((v) => v.id === action.payload.id)
      if (index !== -1) {
        state.list[index] = action.payload
      }
    },
  },
})

export const { setVideos, addVideo, updateVideoInList } = videoSlice.actions
export default videoSlice.reducer
// src/services/analyticsService.ts
import api from './api'

export interface AnalyticsData {
  views: number
  likes: number
  comments: number
  // Other metrics as needed
}

export const getAnalytics = async (): Promise<AnalyticsData> => {
  const response = await api.get('/analytics') // <TODO>: Adjust endpoint
  return response.data
}
// src/services/api.ts
import axios from 'axios'

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api', // Base URL from env
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor to attach JWT token
api.interceptors.request.use(
  (config) => {
    if (typeof window !== 'undefined') {
      const token = localStorage.getItem('token') // Or get from Redux store
      if (token && config.headers) {
        config.headers.Authorization = `Bearer ${token}`
      }
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    // <TODO>: Add global error handling if needed
    return Promise.reject(error)
  }
)

export default api
// src/services/authService.ts
import { User } from '@/modules/auth/authSlice'
import api from './api'

export interface LoginCredentials {
  email: string
  password: string
}

export interface AuthResponse {
  user: User // Replace with actual user type
  token: string
}

export const login = async (
  credentials: LoginCredentials
): Promise<AuthResponse> => {
  const response = await api.post('/auth/login', credentials) // <TODO>: Update endpoint if needed
  return response.data
}

export const register = async (data: User): Promise<AuthResponse> => {
  const response = await api.post('/auth/register', data) // <TODO>: Update endpoint if needed
  return response.data
}

export const logout = async (): Promise<void> => {
  await api.post('/auth/logout') // <TODO>: Update endpoint if needed
}
// src/services/ttsService.ts
import api from './api'

export interface TTSConfig {
  voice: string
  speed: number
  tone: number
  volume: number
}

export const getTTSConfig = async (): Promise<TTSConfig> => {
  const response = await api.get('/tts/config') // <TODO>: Adjust endpoint
  return response.data
}

export const updateTTSConfig = async (
  config: Partial<TTSConfig>
): Promise<TTSConfig> => {
  const response = await api.put('/tts/config', config) // <TODO>: Adjust endpoint
  return response.data
}
// src/services/uploadService.ts
import api from './api'

export const uploadFile = async (fileData: FormData): Promise<unknown> => {
  // If using pre-signed URL approach, modify accordingly.
  const response = await api.post('/upload', fileData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  }) // <TODO>: Adjust endpoint
  return response.data
}
// src/services/videoService.ts
import api from './api'

export interface Video {
  id: string
  title: string
  status: string
  // Other fields as needed
}

export const fetchVideos = async (): Promise<Video[]> => {
  const response = await api.get('/videos') // <TODO>: Adjust endpoint
  return response.data
}

export const uploadVideo = async (videoData: FormData): Promise<Video> => {
  const response = await api.post('/videos/upload', videoData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  }) // <TODO>: Adjust endpoint
  return response.data
}

export const updateVideo = async (id: string, data: Video): Promise<Video> => {
  const response = await api.put(`/videos/${id}`, data) // <TODO>: Adjust endpoint
  return response.data
}
// src/store/authSlice.ts
import { User } from '@/modules/auth/authSlice'
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface AuthState {
  user: User | null
  token: string | null
}

const initialState: AuthState = {
  user: null,
  token: null,
}

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setCredentials(
      state,
      action: PayloadAction<{ user: User; token: string }>
    ) {
      state.user = action.payload.user
      state.token = action.payload.token
    },
    logout(state) {
      state.user = null
      state.token = null
    },
  },
})

export const { setCredentials, logout } = authSlice.actions
export default authSlice.reducer
// src/store/settingsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface SettingsState {
  theme: 'light' | 'dark'
  language: string
}

const initialState: SettingsState = {
  theme: 'light',
  language: 'en',
}

const settingsSlice = createSlice({
  name: 'settings',
  initialState,
  reducers: {
    setTheme(state, action: PayloadAction<'light' | 'dark'>) {
      state.theme = action.payload
    },
    setLanguage(state, action: PayloadAction<string>) {
      state.language = action.payload
    },
  },
})

export const { setTheme, setLanguage } = settingsSlice.actions
export default settingsSlice.reducer
// src/store/store.ts
import { configureStore } from '@reduxjs/toolkit'
import { useDispatch } from 'react-redux'
import authReducer from './authSlice'
import videoReducer from './videoSlice'
import settingsReducer from './settingsSlice'
import ttsReducer from './ttsSlice'

const store = configureStore({
  reducer: {
    auth: authReducer,
    video: videoReducer,
    settings: settingsReducer,
    tts: ttsReducer,
  },
  // Optional: middleware, devTools, etc.
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch

// Custom hook to use dispatch with correct type
export const useAppDispatch = () => useDispatch<AppDispatch>()

export default store
// src/store/ttsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface TTSState {
  voice: string
  speed: number
  tone: number
  volume: number
}

const initialState: TTSState = {
  voice: 'default',
  speed: 1,
  tone: 1,
  volume: 1,
}

const ttsSlice = createSlice({
  name: 'tts',
  initialState,
  reducers: {
    setTTSConfig(state, action: PayloadAction<Partial<TTSState>>) {
      Object.assign(state, action.payload)
    },
  },
})

export const { setTTSConfig } = ttsSlice.actions
export default ttsSlice.reducer
// src/store/videoSlice.ts
import { Video } from '@/modules/dashboard/dashboardSlice'
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface VideoState {
  videos: Video[]
  loading: boolean
  error: string | null
}

const initialState: VideoState = {
  videos: [],
  loading: false,
  error: null,
}

const videoSlice = createSlice({
  name: 'video',
  initialState,
  reducers: {
    fetchVideosStart(state) {
      state.loading = true
      state.error = null
    },
    fetchVideosSuccess(state, action: PayloadAction<Video[]>) {
      state.videos = action.payload
      state.loading = false
    },
    fetchVideosFailure(state, action: PayloadAction<string>) {
      state.loading = false
      state.error = action.payload
    },
    // Additional reducers for create, update, delete video actions
  },
})

export const { fetchVideosStart, fetchVideosSuccess, fetchVideosFailure } =
  videoSlice.actions
export default videoSlice.reducer
// src/utils/authHelper.ts
import { jwtDecode } from 'jwt-decode'

interface JwtPayload {
  exp: number
  [key: string]: string | number | boolean | object | null
}

export function getTokenExpiration(token: string): number {
  const decoded: JwtPayload = jwtDecode<JwtPayload>(token)
  return decoded.exp
}

export function isTokenExpired(token: string): boolean {
  const expiration = getTokenExpiration(token)
  const now = Date.now() / 1000
  return expiration < now
}
// src/utils/debounce.ts
export function debounce<F extends (...args: unknown[]) => void>(
  func: F,
  delay: number
): (...args: Parameters<F>) => void {
  let timeoutId: ReturnType<typeof setTimeout>
  return (...args: Parameters<F>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }
}
// src/utils/fetchHelper.ts
import axios from 'axios'

export async function fetchData<T>(url: string, options = {}): Promise<T> {
  const response = await axios.get<T>(url, options)
  return response.data
}
// src/utils/formatDate.ts
export function formatDate(date: Date | string): string {
  const d = new Date(date)
  return d.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  })
}
// src/queryClient.ts
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Customize default query settings (e.g., staleTime, cacheTime)
      staleTime: 60000, // 1 minute
      retry: 1,
    },
  },
})

export default queryClient
